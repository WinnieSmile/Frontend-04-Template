<!--
 * @Author: your name
 * @Date: 2020-08-23 22:33:08
 * @LastEditTime: 2021-02-15 16:36:10
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \Frontend-04-Template\Week_07\README.md
-->
# HTML解析 （词法分析）   
HTML parse模块的文件拆分   
从一个URL变成一个HTTP请求，然后拿到了它的 response，并且对它进行了一些初步的解析，可以得到 response里面的body。
## 第一步：文件的拆分   
要想实现一个parser，首相想象一下它是怎么用的，所以会先在client.js里写它的调用的部分。
主要代码： 
client.js 文件  
```javascript
const parser = require("net");  //把parser单独放到一个文件里，即require一个parser.js文件


void async function(){
    let request = new Request({   
        method: "POST",           
        host: "127.0.0.1",       
        port: "8088",             
        path: "/",                
        headers: {
            ["X-Foo2"]: "customed"
        },
        body: {
            name: "winter"
        }
    });
    
    let response = await request.send();  //从一个request得到一个response。

    /**
     * 把API设计成：完整的得到response之后，然后再对parser进行处理，把这个body交给parser去处理。
     * 实际上如果写真正的浏览器的话，需要逐段的返回response body的，然后逐段的去给 parser。
     * 这里采用的办法是：把body全收回来，然后再交给HTML parser的这样的操作。实际上是应该做成异步分段处理的。
     */
    let dom = parser.parseHTML(response.body); //把HTML得到了以后，把它通过parser的parserHTML方法把它变成一个DOM树。

}();
```
parser.js 文件
```javascript
module.exports.parserHTML = function parseHTML(html){
    console.log(html);
}
```
总结：第一步总结
* 为了方便文件管理，我们把parser单独拆到文件中   
* parser接受HTML文本作为参数，返回一棵DOM树   
 
## 第二步 用FSM实现HTML的分析    
解析HTML这种文本类的操作，一定会用到状态机，HTML文本的解析也不例外，所以第二步首先我们要创建一个状态机，但是在创建状态机之前我们首先要知道HTML的语法。   

**HTML标准：html.spec.whatwg.org/multipage/**     

在标准中找到 **Tokenization** （13.2.5章节，有可能版本不对） 讲HTML词法的这一章。它整个的描述方式完全就是一台状态机。    
在HTML标准里面一共有80个状态，但是大部分的状态不需要用到。    

第二步总结：     
* 我们用FSM来实现HTML的分析   
* 在HTML标准中，已经规定了HTML的状态   
* Toy-Browser至挑选其中一部分状态，完成一个最简版本   

## 第三步 解析标签    
把状态机里边的状态写出来，尝试把HTML里面的所有的tag做一个解析，HTML里面的tag有三种：    
* 开始标签
* 结束标签
* 自封闭标签

总结：
* 主要的标签有：开始标签、结束标签、自封闭标签
* 在这一步我们暂时忽略属性
    

## 第四步骤
状态机最大的作用是在每一个状态里可以做一些计算，如何通过状态机里面的每一个状态在里面适当的位置插入我们自己的计算逻辑，然后来求出我们想要的token。     
总结：    
* 在状态机中，除了状态迁移，我们还会要加入业务逻辑（在parser的代码里边，业务逻辑就是创建token，然后把字符加到token上，最后emit token）
* 在标签的结束状态就会提交标签token，注意：不是在结束标签才提交整个的token，开始标签和结束标签在词法的角度来讲是两个不同的token，中间是一堆文本节点，还没有构建树结构。

## 第五步骤
* 属性值分为单引号、双引号、无引号三种写法，因此需要较多状态处理。
* 处理属性的方式跟标签类似 （用一个全局的对象去暂存）
* 属性结束时，我们把属性加到标签Token上；所以最后 emit 的还是标签token。

# HTML解析 （语法分析）
HTML语言它的语法分析时非常简单的，它不像复杂的JS，还有各个不同层级的结构，HTML语法用一个栈就可以完成它的分析，但是在toy browser里用一个栈，不需要加任何的特例就可以解决掉，如果说要做一个真正的浏览器，光用栈式不行的，它还要加很多的特殊处理，比如说标签没有好好写封闭等，HTML都会包容。     
如何用已经准备好的token去构建一棵DOM树。    
用栈去构建DOM树的原理：         
栈跟树这两个数据结构是有一种天然的联系，任何一个树的一个截面，它的父元素父元素都可以视为一个栈，所以遍历树的过程也可以理解为一个栈的这样的一个结构的过程。    
根据一个非常简单的规则，我们可以用一个 stack 把这棵树构建出来。      

查看标准：html.spec.whatwg.org/multipage/       
13.2.6 Tree construction 描述了在各种状态下，我们应该怎样去配对这些标签。      
## 第六步总结     
* 从标签构建DOM树的基本技巧是使用栈   
* 遇到开始标签时创建元素并入栈，遇到结束标签时出栈   
* 自封闭节点可视为入栈后立刻出栈   
* 任何元素的父元素是它入栈前的栈顶   
## 第七步总结    
* 文本节点与自封闭标签处理类似（其实并不会真的去入栈，但是这个文本节点跟自封闭标签不同的是因为我们token是一个一个过来的，多个文本节点它最终是需要合并的）
      

# CSS计算    
通过HTML解析得到 DOM 树，通过CSS计算生成一棵带 CSS 属性的 DOM 树。    
CSS计算，实际上CSS Computing这个词，它表示的就是把我们CSS规则里头所包含的那些CSS属性应用到匹配这些选择器的元素上去。是一个非常清晰、非常熟悉的一个过程。   
整个浏览器的架构    
URL  → HTML  →  parse  →  DOM  →  css computing  →  DOM with CSS  →  layout  →  DOM with position  →  render  →  Bitmap    
把一个URL变成HTML、把HTML代码变成DOM树这样的一个过程。    
用npm上的一个现成的包（css），它其实是一个CSS parser，这个 CSS parser可以帮我们完成 把CSS的代码变成 AST抽象语法树这样的过程，这会极大地降低我们的工作量。   
根据这棵抽象语法树来抽出各种CSS规则，并且把它们应用到HTML元素上。所以说CSS computing的过程虽然是号称是CSS computing，其实它是发生在DOM树构建的时候    
## 第一步：收集CSS规则   
* 遇到style标签时，我们把CSS规则保存起来    
* 这里我们调用CSS Parser来分析CSS规则
* 这里我们必须要仔细研究此库分析CSS规则的格式 【重要：产生AST的结构】   
## 第二步：添加调用    
把CSS规则应用上去，应用的时机是越早越好，在CSS的设计里面，有一条隐藏的潜规则，就是CSS设计会尽量保证所有的选择器都能够在 startTag 进入的时候就能够被判断，后面加了一些高级的选择器之后，这个规则开始有了一定的松动，但是大部分的规则仍然遵循这个规则：当我们DOM树构建到你的元素的startTag的步骤，就已经可以判断出来，它能够匹配哪些CSS规则了。         
总结：     
* 当我们创建一个元素后，立即计算CSS     
* 理论上，当我们分析一个元素时，所有CSS规则已经收集完毕，也就是说所有的head的里面的元素，其实是没有办法计算它的CSS的。    
* 在真实的浏览器中，可能遇到写在body的style标签，需要重新CSS计算的情况，这里我们忽略。   
## 第三步：获取父元素序列   
为什么要获取父元素序列？    
因为我们今天的选择器它大多数都是跟元素的父元素相关的。   
总结；   
* 在computeCSS函数中，我们必须要知道元素的所有父元素才能判断元素与规则是够匹配：因为CSS规则里有这种子孙选择器、直接子元素选择器这一类的这样的选择规则。    
* 我们从上一步骤的stack，可以获取本元素所有的父元素  
* 因为我们首先获取的是 “当前元素”，所以我们获得和计算父元素匹配的顺序是从内向外   
    div div #myid
    前面两个 div这两选择器，因为是用空格，所以它是一个子孙选择器，我们不确定这两个 div 到底要跟哪个父元素匹配，而最后一个myid的元素，它是一定会跟当前元素相匹配的    
    所以，要想高效地去实现一个CSS选择器的匹配规则，那么我们一定是先去检查最后一个 myid 选择器。不管它是什么选择器，不管是# .还是同样的 tagName 选择器，一定是先检查它是够匹配当前元素的。所以计算父元素的匹配顺序就都是会 从内向外。
## 第四步：   
开始处理选择器跟元素的匹配问题    
选择器其实有一个层级结构，最外层是选择器列表（CSS parser部分已经做了拆分），选择器列表里边叫做复杂选择器，复杂选择器是由空格分割的的一系列复合选择器。复杂选择器是根据亲代关系，然后去选择元素的，而复合选择器是针对一个元素的本身的属性和特征的一个判断，而复合选择器是由紧连着的一堆的简单选择器而构成的。    
在toy browser里假设它只包含简单选择器，不处理复合的情况。   
拆分选择器：只需要对复杂选择器根据空格进行一下拆分。      
总结：    
* 选择器也要从当前元素向外排列     
* 复杂选择器拆成针对单个元素的选择器，用循环匹配元素队列  
## 第五步：      
* 根据选择器的类型和元素属性，计算是否与当前元素匹配        
* 这里仅仅实现了三种基本选择器，实际的浏览器中要处理复合选择器    
* 作业（可选）：实现复合选择器，实现支持空格的Class选择器。    
## 第六步：   
* 一旦选择匹配，就应用选择器到元素上，形成computedStyle
## 第七步：   
specificity的计算逻辑    
根据单个的复杂选择器去加起来计算的     
例如下面的四元组：  
```
[0,     0,      0,      0]    

inline  id      class   tagName    

```   
inline：写在style上的css属性。优先级是1。    
（一旦在style属性里写这个优先级的话，它的整个的覆盖关系里面它就是最高的；如果有id的话，id的优先级是最高）      
```
例1：
div     div     #id 

[0,     1,      0,      2]  
  

例2：   
div     #my     #id  

[0,     2,      0,      1]   


例3：   
div     .cls     #id  

[0,     1,      0,      1]

```        
比较四元组大小的时候，会采取进位制    
只要高位能够比较出来，就不考虑低位。       

总结：    
* CSS规则根据specificity和后来优先规则覆盖   
* specificity是个四元组，越左边权重越高。   
* 一个CSS规则的specificity根据包含的简单选择器相加而成。















