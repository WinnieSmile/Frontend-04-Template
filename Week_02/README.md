# 一、寻路
## 广度优先搜索  

* 广度优先搜索BFS（Breadth First Search）也称为宽度优先搜索，它是一种先生成的结点先扩展的策略。类似于树的遍历。  
* 广度优先搜索算法的搜索步骤一般是：  
（1）从队列头取出一个结点，检查它按照扩展规则是否能够扩展，如果能则产生一个新结点。  
（2）检查新生成的结点，看它是否已在队列中存在，如果新结点已经在队列中出现过，就放弃这个结点，然后回到第（1）步。否则，如果新结点未曾在队列中出现过，则将它加入到队列尾。   
（3）检查新结点是否目标结点。如果新结点是目标结点，则搜索成功，程序结束；若新结点不是目标结点，则回到第（1）步，再从队列头取出结点进行扩展。    
**最终可能产生两种结果；找到目标结点，或扩展完所有结点而没有找到目标结点。**    

* 如果目标结点存在于解答树的有限层上，广度优先搜索算法一定能保证找到一条通向它的最佳路径，因此广度优先搜索算法特别适用于只需求出最优解的问题。当问题需要给出解的路径，则要保存每个结点的来源，也就是它是从哪一个节点扩展来的。  

* JavaScript数组就是一个天然的队列，也是一个天然的栈。   
* 数组的方法有`shift、unshift` 和 `push、pop`如果`push`和`shift`相对，那么它就是一个队列，`pop`如果和`unshift`联合使用也是一个队列；`push`和`pop`联合使用就是一个栈。    


## 启发式寻路  

* 启发式寻路：用一个函数去判断它的这些点扩展的优先级，只要判断好了优先级就可以有目的地去寻路。  
（1）比如说沿着点的方向去做优先地去找寻路，只要启发式函数所使用的估值能够一定小于这个点到终点的路径，那么它就一定能找到最优路径。  
（2）在计算机领域，通过启发式寻路能够找到最优路径，称为 A*; 不一定找到最终的启发式寻路称为 A。A*是A寻路的特例。 

* 实现 `Sorted` 这个数据结构
``` javascript
class Sorted{
    constructor(data, compare){ 
        this.data = data.slice();   //保存一份data
        this.compare = compare || ((a, b) => a - b);  
    }
    // 每次take时都拿出一个最小的
    take(){
        if (!this.data.length) {
            return;     
        }
        let min = this.data[0];   // 存最小的数 (默认从0开始)
        let minIndex = 0;         // 存最小的位置

        // 循环从1开始
        for(let i = 1; i < this.data.length; i++){
            if (this.compare(this.data[i], min) < 0) {
                min = this.data[i];  
                minIndex = i;
            }
        }
        // 把数组和最后一个元素交换，把最后一个元素用新的点覆盖掉了
        this.data[minIndex] = this.data[this.data.length - 1];          
        this.data.pop();
        return min;
    }
    give(v){
        this.data.push(v);   
    }
}
```

执行：
``` javascript
// 定义一个无序数组
let s = new Sorted([7, 3, 9, 6, 5, 4, 8, 0, 2])
s.take();  

// 使用sort()
[7, 3, 9, 6, 5, 4, 8, 0, 2].sort()
// 执行
[0, 2, 3, 4, 5, 6, 7, 8, 9]
```

# 二、使用LL算法构建AST
* 四则运算
* 正则表达式
* LL词法分析
* LL语法分析

