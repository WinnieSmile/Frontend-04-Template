<!--
 * @Author: your name
 * @Date: 2020-08-23 22:33:08
 * @LastEditTime: 2020-09-20 23:54:21
 * @LastEditors: your name
 * @Description: In User Settings Edit
 * @FilePath: \Frontend-04-Template\Week_03\README.md
-->
# 一、字符串分析算法
* 字典树
    * 大量高重复字符串的存储与分析

精确地匹配字符串模式，看两个字符串是否是精确相等的。字典树是用来处理大量的高重复字符串的存储和分析问题。  
比如要处理1亿个字符串里边有多少出现（频率）前50的这种数量的字符串。要怎样处理。这种就是字符串海量的处理情况。1亿个个字符串时可以用字典树来进行存储处理的。例如搜索关键词等。
* KMP
    * 在字符串里找模式
    
检查一个长字符串里面有没有一个短字符串的部分，是一个部分匹配。与字典树最大的区别就是字典树是检查两个字符串是否完全匹配，KMP是两个字符串中，一个字符串时另一个字符串的部分。  
KMP，如果一个长度为 m 的字符串、一个长度为 n 的字符串，它俩互相匹配。最差可能是一个 m 乘以 n 的时间复杂度。
* Wildcard
    * 带通配符的字符串模式
      
在KMP的基础上加了通配符，通配符就是会有问号?、星号*。   
问号表示匹配任意字符，星号表示匹配任意数量的任意字符。 比如做文件查找的时候可能会用到 Wildcard。   
Wildcard是可以在O(n)的时间复杂度上处理掉，也可以是 O(m+n)的这样的规模去处理掉。例如贪心算法。
* 正则表达式
    * 字符串通用模式匹配  

需要用到回溯的一个系统，可以说是字符串匹配的终极版本。
* 状态机
    * 通用的字符串分析
* LL LR
    * 字符串多层级结构分析   

LL语法分析的算法，LR是一个比LL更强大的语法分析。LR理论性较强。  
HTML语法用stack来处理，实际上就是 LR 算法的一个简化版。其实是LR(0)的语法。一般都会用LR(1)。 LR(1)是可以等于到LL(n)的强大算法。
  
    
## 字典树
通过 Trie找到字典树最小、字典树最大的情况。  
字典树在处理大量输入和字符串的问题的时候的优势。  
如果对数字进行补位处理，比如说把1变成 0001 ，那么 1 万以内的数字，想求最大或最小，不管数字有多少个，都可以方便地去做了。  
字典树其实是哈希树的一种特例。哈希树在字符串领域里边最直接的应用体现是字典树；处理数字的话可以用别的哈希算法，来构造别的哈希算法。  
例子：把一个字符串插进字典树里面。存一个字符串，找字典树最小的一个；求出现最多的次数的情况（例如：10万次的插入，只出现了 5 次的重复。）

## KMP
KMP是一个字符串的模式匹配算法，模式匹配就是查一个字符串里边有没有另一个字符串。原串就是待查的串，有一个比较短的叫做 pattern 串，pattern串就是用于表示：要在长串里面去找短的字符串。  
Brute-Force（BF）暴力解法：从长的字符串的每一个节点开始，从它的每个位置开始，然后去匹配，看有没有能够匹配到 pattern 的串。这个算法的时间复杂度是 m*n。 如果说原串和模式串它们两个的长度各为 m n 的话，那么他就是 m 乘以 n 的时间复杂度。  

## Wildcard
加入了两种通配符 *  ? 。比较复杂是情况是*和?混合起来的情况，这种可以简化分析，先只考虑两种情况，第一种是只有星号的情况，第二种是只有问号的情况。
* wildcard : ab*c?d*abc*a?d
    * 只有* : ab*cd*abc*a?d
    * 只有? : c?d, a?d


# 二、proxy与双向绑定
* 基本语法
